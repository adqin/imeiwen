<?php

echo '<pre>';
print_r($_SERVER);
return;

$abc = '<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>

<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>

<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>

<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
        <p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
<p>首先遇到的问题是,部署nodejs的博客程序时,我把执行nodejs的命令放到后台,使用加&和nohup命令</p>
<p>如:nodejs index.js & 或者 nohup nodejs index.js &</p>
<p>&这个使用是当退出此次终端会话的时候就会停止, nohup这个命令理论上是可以后台一直执行的,但是当出现某些异常的时候,还是会退出.</p>
<p>进程的基础概念</p>
<p>进程是执行程序的过程.unix系统的老祖宗内核进程的ppid都是是0,比如:init进程的pid是1,ppid是0;其他进程都是从init进程的基础上fork出来的,使用pstree命令可以看到进程树</p>
měi hǎo';

echo strlen($abc);
echo "<br />";

$re = rtrim(strtr(base64_encode(gzdeflate($abc, 9)), '+/', '-_'), '=');
echo $re;
echo "<br />";
echo strlen($re);

echo "<br />";
echo gzinflate(base64_decode(strtr($re, '-_', '+/')));
//$out = gzinflate($re);

